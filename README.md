# ESP32: Зашифрований зв'язок з RF-модулем 433 МГц та одноразовим блокнотом

Цей проєкт демонструє захищений зв'язок між двома мікроконтролерами ESP32 за допомогою RF-передавача/приймача 433 МГц та спрощеної схеми шифрування одноразовим блокнотом (OTP).

**ВАЖЛИВО: Це демонстраційний код. Він призначений *виключно* для ілюстрації можливостей роботи з радіосигналами та одноразовим блокнотом на ESP32.  Він *не* призначений для використання в реальних системах, де потрібна справжня безпека.  Див. розділ "Міркування безпеки" для отримання додаткової інформації.**

**Особливості:**

*   **Шифрування:** Використовує одноразовий блокнот (на основі XOR) для шифрування та дешифрування повідомлень.  *Примітка: Ця реалізація використовує спрощений OTP для демонстраційних цілей.*
*   **RF-зв'язок 433 МГц:** Використовує бібліотеку `RadioHead` для надійної передачі даних через радіоканал 433 МГц.
*   **Сумісність з ESP32:** Розроблено для платформи мікроконтролера ESP32.
*   **Чітка структура коду:** Містить добре прокоментований код з окремими функціями для шифрування, дешифрування, передачі та прийому.
*   **Послідовне налагодження:** Забезпечує послідовний вивід для моніторингу процесу передачі та прийому.

**Необхідне обладнання:**

*   Дві плати розробки ESP32 (наприклад, NodeMCU-32S, ESP32-WROOM-32).
*   Два RF-модулі передавача/приймача 433 МГц (наприклад, передавач FS1000A та приймач XY-MK-5V).  Переконайтеся, що обидва модулі працюють на одній частоті (433 МГц).
*   З'єднувальні дроти.
*   Відповідні антени для модулів передавача та приймача.

**Необхідні бібліотеки:**

*   **RadioHead:** Встановіть через Менеджер бібліотек Arduino (Скетч -> Підключити бібліотеку -> Керувати бібліотеками...).  Шукайте "RadioHead" від Mike McCauley.
*   **SPI:** Ця бібліотека вбудована в Arduino IDE.

**Підключення:**

Підключіть RF-модулі до плат ESP32 наступним чином:

| RF Модуль (Пін) | ESP32 Пін (За замовчуванням - див. код) | Опис              |
| :------------- | :-------------------------------------- | :---------------- |
| DATA (TX)     | 12                                      | Передача даних   |
| DATA (RX)     | 13                                      | Прийом даних     |
| VCC           | 3.3V                                    | Живлення (3.3V)  |
| GND           | GND                                     | Земля             |
| PTT           | 2 (Необов'язково)                      | Push-to-Talk (якщо використовується) |

**Примітка:** Деякі RF-модулі не потребують піна PTT.  Якщо ваш модуль не має піна PTT, закоментуйте рядок `#define RF_PTT_PIN` у коді.  Змініть визначення пінів (`RF_TX_PIN`, `RF_RX_PIN`, `RF_PTT_PIN`) у коді, якщо ви використовуєте інші піни.

**Як використовувати:**

1.  **Встановіть бібліотеки:** Встановіть необхідні бібліотеки, як описано вище.
2.  **Підключіть обладнання:** Підключіть RF-модулі до плат ESP32, як показано в таблиці підключень.
3.  **Відкрийте код:** Відкрийте наданий файл `esp32_rf_otp.ino` в Arduino IDE.
4.  **Завантажте та протестуйте:**
    *   Завантажте код на *обидві* плати ESP32.
    *   Відкрийте Послідовний монітор на *обох* платах ESP32 (встановіть швидкість передачі даних 115200).
    *   Один ESP32 повинен відображати повідомлення, що починаються з "Sending:". Інший - з "Received encrypted:".
5.  **Налаштуйте (необов'язково):**
    *   **Змініть повідомлення:** Змініть вміст масиву `message[]` у функції `loop()`, щоб надіслати інше повідомлення.
    *   **Налаштуйте параметри RF:** Змініть константу `RF_SPEED`, щоб експериментувати з різними швидкостями передачі даних.  Нижчі швидкості, як правило, забезпечують кращий діапазон і надійність.
    *   **Змініть ключ:** Змініть масив `key[]`.  *Для демонстраційних цілей ключ короткий і використовується повторно.*

**Структура коду:**

*   **`encryptMessage()`:** Шифрує повідомлення за допомогою одноразового блокнота (операція XOR).
*   **`decryptMessage()`:** Дешифрує повідомлення за допомогою одноразового блокнота (операція XOR).  В OTP дешифрування таке саме, як і шифрування.
*   **`setup()`:** Ініціалізує послідовний зв'язок та RF-модуль.
*   **`loop()`:** Містить основну логіку для надсилання та отримання повідомлень. Включає як частини передачі, так і прийому. Для тестування на двох різних платах ESP32 вам потрібно буде закоментувати/розкоментувати частини надсилання або отримання відповідно.
*   **Надсилання:**
    *   Визначає повідомлення, яке потрібно надіслати.
    *   Шифрує повідомлення.
    *   Надсилає зашифроване повідомлення за допомогою `rf_driver.send()`.
    *   Очікує завершення передачі.
*   **Отримання:**
    *   Перевіряє наявність вхідних повідомлень за допомогою `rf_driver.recv()`.
    *   Якщо повідомлення отримано, дешифрує його.
    *   Виводить отримані та розшифровані повідомлення в Послідовний монітор.
      
**Виправлення неполадок:**

*   **"RF module initialization failed!":** Перевірте підключення та переконайтеся, що RF-модуль належним чином живиться.  Переконайтеся, що ви вибрали правильний тип плати ESP32 і порт в Arduino IDE.
*   **Немає отриманих даних:** Переконайтеся, що модулі передавача та приймача працюють на одній частоті (433 МГц).  Перевірте підключення антен.  Спробуйте зменшити `RF_SPEED`, щоб підвищити надійність.  Збільште відстань між передавачем і приймачем (іноді занадто близьке розташування може спричинити проблеми).
*   Незрозумілий текст в Serial Monitor: Переконайтесь що вірно виставлена швидкість (115200).

**Подальша розробка:**

*   **Обробка помилок:** Реалізуйте механізми виявлення та виправлення помилок (наприклад, контрольні суми, CRC) для обробки потенційного пошкодження даних під час передачі.
*   **Підтвердження:** Додайте систему підтвердження для підтвердження успішної доставки повідомлення.
*   **Довші повідомлення:** Змініть код, щоб обробляти повідомлення, довші за `RH_ASK_MAX_MESSAGE_LEN`.  Це може включати розбиття повідомлень на кілька пакетів.
*   **Управління живленням:** Оптимізуйте код для низького споживання енергії, особливо для додатків, що живляться від батарей.  Використовуйте режими глибокого сну ESP32.
*  **Реальна імплементація OTP:** Вирішіть проблеми безпеки, реалізувавши безпечний механізм генерації, розповсюдження та використання ключів.

Цей вичерпний README повинен стати гарною відправною точкою для всіх, хто цікавиться цим проєктом.
